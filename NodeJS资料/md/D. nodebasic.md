title: D.node基础
transition: cards
theme: blue
highlightStyle:javascript

[slide]
##node是什么
- Node.js是一个让JS可以运行在浏览器之外的<span class="red">服务器端</span>的平台   {:&.zoomIn}
- 它实现了诸如文件系统、模块、包、<span class="red">操作系统API</span>，网络通信等核心JS没有或不完善的功能   
- 它摒弃传统平台依赖多线程来实现高并发的设计思路，而采用<span class="red">单线程</span>，<span class="red">异步式I/O</span>，<span class="red">事件驱动</span>式的程序设计模型  
- Node.js使用了来自于Google ChromeV8引擎。V8是目前世界上<span class="red">最快</span>的Javascript引擎


[slide]
#node.js的优点
* Nodejs基于Javascript语言 {:&.zoomIn}
* *统一*公共类库，代码*标准*化
* Nodejs选择了目前最*快*的浏览器内核V8做为执行引擎
* Nodejs的社区非常*活跃*

[note]
- Nodejs基于Javascript语言，不用再单独新学一门陌生的语言，从而减低了学习的门槛。
同时，Javascript语言在Web前端开发中至关重要，特别HTML5的应用必须要使用，所以前后台统一语言，
不仅可以实现程序员的全栈开发，还可以统一公共类库，代码标准化。单凭这一点，Nodejs就已经赢得市场的青睐了。
- Nodejs并没有重新开发运行时环境，而是选择了目前最快的浏览器内核V8做为执行引擎，保证了Nodejs的性能和稳定性。
- Nodejs的开发非常高效，而且代码简单，得益于Nodejs的单线程机制。而Nodejs的另一个特点异步编程，
让Nodejs处理IO密集型应用有了明显的优势。个人感觉，用Nodejs比Java做Web开发要高效10倍，比PHP的代码还要简单。
- Nodejs的社区在壮大，不仅包的数量在快速增加，而且包的质量也要明显好于其他语言的。很多明星级的包，都是简单而灵巧的，
为了开发者的使用习惯而设计。我最常用到的工具包，如socket.io, moment.js, underscore.js, async.js,  
 express.js, bower.js, grunt.js, forever.js…，确实在改变我以前的编程习惯。  
- 动态语言：开发效率非常高，并有能力构建复杂系统，如ql.io。  
- 性能和I/O负载：Nodejs非常好的解决了IO密集的问题，通过异步IO来实现。  
- 连接的内存开销：每个Node.js进程可以支持超过12万活跃的连接，每个连接消耗大约2K的内存。  
- 操作性：实现了Nodejs对于内存堆栈的监控系统。  
[/note]

[slide]
#NODE概念
<img src="http://7xjf2l.com2.z0.glb.qiniucdn.com/nodeeat.jpg" class="img-responsive">

[slide]
##什么是回调
* 异步编程基本的方法，需要异步处理的时候一般采用<span class="text-warning">后续传递</span>的方式。
* 将后续逻辑作为函数<span class="text-warning">参数</span>

[slide]
##同步和异步
* 同步是指发起调用之后主线程只能挂起,调用者<span class="text-warning">主动</span>等待这个调用的结果
* 异步是指发起调用之后主线程可以做别的事情,被调用者通过<span class="text-warning">通知</span>来告知调用者结果

[note]
1. 所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。
换句话说，就是由调用者主动等待这个调用的结果。
2. 而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。
换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。
而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。
让厨师做饭的时候,服务员可以不等待
[/note]

[slide]
##什么是阻塞/非阻塞
* 针对<span class="red">内核</span>来说的,向内核发起请求的时候不会阻塞主线程的执行
* 非阻塞是实现异步的<span class="red">前置</span>条件

[note]
1. 针对内核来说的,向内核发起请求的时候不会阻塞主线程的执行
2. 非阻塞是实现异步的前置条件
[/note]


[slide]
##什么是IO
* Input(输入) 从文件系统中<span class="red">读取</span>文件
* Output(输出) 向文件系统<span class="red">写入</span>文件

[slide]
##什么是单线程/多线程
* 单线程指程序按<span class="red">顺序</span>执行，前面流程执行完毕之后,后面的流程才能执行到
* 多线程指<span class="red">同时</span>可以执行多个任务，比如一边看电视，一边睡觉,通过系统线程<span class="red">上下文切换</span>来弥补同步式IO调用时的时间开销
* Node单线程指的是<span class="red">主线程</span>是单线程的，所有阻塞的部分交给一个<span class="red">线程池</span>处理，然后这个主线程通过一个队列跟线程池协作

[note]
1. JS代码按顺序执行并且一次只能执行一次
2. 程序按顺序执行，前面流程执行完毕之后后面的流程才能执行到
3. 一边打看电视，一边磕瓜子,还能一边聊天
1. node.js除了代码都是多线程的。
2. 对于高并发的解决方案，传统的架构是采用多线程模型，也就是为每个业务逻辑提供一个线程，
通过系统线程切换来弥补同步式IO调用时的时间开销，
3. Node.js使用了单线程模型，对于所有的IO都采用了异步式的请求方式，避免了频繁的上下文切换。
既然 Node.js 是单线程，又是怎么做到支持异步函数调用的？
4. 单线程指的是主线程是“单线程”的，所有阻塞的部分交给一个线程池处理，然后这个主线程通过一个队列跟线程池协作，
于是对我们写到的js代码部分，不再关心线程问题，代码也主要由一堆callback回调构成，然后主线程在不停的循环过程中，
适时调用这些代码。
[/note]


[slide]
##什么是事件
是指发生了某种事情，这件事情会<span class="red">触发</span>其它动作的发生

[note]
鼠标点击是一个事件
注册函数不会马上执行，只有事件发生的事情才会执行
[/note]


[slide]
##什么是基于事件驱动的回调函数
不是立刻执行，而是等某个<span class="red">事件发生</span>之后才会执行的函数就叫基于事件驱动的回调函数

[note]
1. 这种回调就是基于事件驱动的回调
2. 基于回调的异步IO
[/note]


[slide]
##什么是事件循环
* 管理异步动作、定时器和回调函数的机制叫<span class="red">事件环</span>
* 异步的时候就会压入到这个队列，然后不停读取事件，事件发生后会把对应的回调<span class="red">加入队列</span>
* 队列按加入的<span class="red">顺序</span>依次执行，由普通函数和回调函数组成。

[note]
1. 有大量的异步操作，定时器之类的它们完成的时候都要完成回调函数，完成密集任务
，这些大量的事件需要管理，这种管理机制就是事件循环
2. 异步的时候就会压入到这个队列，启动一个单线程不断查询是否有事件，读到事件后调用关联的回调函数
3. 这是一个先进先出的队列结构,按加入的顺序依次执行，由普通函数和回调函数组合的队列集合。
1. 在Node.js执行的过程中会维护一个事件队列，程序在执行时进入事件队列循环，等待到下一个事件的到来，
2. 每个异步式调用完成后会被推送到事件队列中，等待程序进行处理。
3. 用户在浏览器中用鼠标点击按钮或输入文字会触发事件，在Node.js中由于客户端请求建立连接，
通过此连接接收提交数据都会触发事件。在Node.js中，在同一个时刻只能执行一个事件回调函数，
4. 但是在执行一个事件回调函数的中途可以转而处理其它事件(包括触发新的事件、声明该事件的回调函数等)，
然后返回继续执行回调函数，这种处理机制称为事件环。
5. EventLoop是一个程序结构，用于等待和发送消息和事件
简单说，就是在程序里设置两个线程，一个负责程序本身的运行，称为主线程，另一个负责主线程与
其它进程(主要是I/O操作)的通信,被称为EventLoop线程(可称为消息线程)
[/note]
